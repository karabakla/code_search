/* some additional functions for quasi-cyclic and quasi-twisted codes

   Markus Grassl <markus.grassl@ug.eud.pl>

   V1.1.1 2023-02-27 fixed a problem with myIsQuasiTwistedCyclic and myIsQuasiCyclic (now calling the Magma function only when fl is true)
   v1.1   2023-02-22 sub-/supercodes added (preliminary)
   v1.0   2023-02-08

   These functions are still preliminary and might change/be renamed in the future.

*/


poly_to_vec:=function(p,V);
// converts the coefficients of the polynomial p into a vector in V,
// appending zeroes
  n:=Degree(V);
  v:=Eltseq(p mod (Parent(p).1^n-1));
  return V!(v cat [0:i in [#v+1..n]]);
end function;

poly_to_vec_alpha:=function(p,V,alpha);
// converts the coefficients of the polynomial p into a vector in V,
// appending zeroes
  n:=Degree(V);
  v:=Eltseq(p mod (Parent(p).1^n-alpha));
  return V!(v cat [0:i in [#v+1..n]]);
end function;


intrinsic QuasiTwistedCyclicCode(n::RngIntElt,Gen::[RngUPolElt],alpha::FldFinElt,h::RngIntElt)->Code
{Constructs the quasi-twisted cyclic code of length n with generator
polynomials given by Gen. Attaches the Generator matrices of the
consta-cyclic codes with parameter alpha generated by Gen
2-dimensionally, stacking with height h. Requires that #Gen be a
multiple of h, and that n be a multiple of #Gen/h}

  require h gt 0 : "Stacking height must be positive integer";
  require #Gen mod h eq 0 : 
       "Number of generator polynomials must be a multiple of h";
  require n mod (#Gen div h) eq 0 : 
       "n must be a multiple of #Gen/h";

  n0:=n div (#Gen div h);
  F:=CoefficientRing(Gen[1]);
  V:=KSpace(F,n0);
  gen_vecs:=[poly_to_vec_alpha(g,V,alpha):g in Gen];

  return QuasiTwistedCyclicCode(gen_vecs,alpha,h);

end intrinsic;

intrinsic QuasiTwistedCyclicCode(Gen::[ModTupRngElt],alpha::FldFinElt,h::RngIntElt)->Code
{Construct the quasi-twisted cyclic code generated by simultaneous
constacylic shifts w.r.t. alpha of the vectors in Gen.  Attaches the
Generator matrices of the consta-cyclic codes with parameter alpha
generated by Gen 2-dimensionally, stacking with height h. Requires
that #Gen be a multiple of h, and that n be a multiple of #Gen/h}

  require h gt 0 : "Stacking height must be positive integer";
  m:=#Gen div h;
  require #Gen mod m eq 0 : 
       "Number of generator polynomials must be a multiple of #Gen/h";

  // return the sum of h one-generator codes
  return &+[QuasiTwistedCyclicCode(Gen[i..i+m-1],alpha):i in [1..#Gen by m]];

end intrinsic;


intrinsic myIsQuasiCyclic(C::CodeLinFld)->BoolElt,RngIntElt
{Returns true iff C is known to be quasi-cyclic. If true, return the index m as well}
  n:=Length(C);
  fl:=exists(m){m:m in Divisors(n)|m ne n and IsQuasiCyclic(C,m)};
  if fl then
    return true,m;
  else
    return false,_;
  end if;
end intrinsic;

intrinsic myIsQuasiTwistedCyclic(C::CodeLinFld:l:=0)->BoolElt,[]
{Returns true iff C is known to be quasi-twisted cyclic with identical shift-constants. If true, return the sequence of shift constants.}
  n:=Length(C);
  units:={x:x in Alphabet(C)|x ne 0};
  if l ne 0 then
    require Length(C) mod l eq 0: "the index does not divide the length of the code";
    require l lt Length(C): "the index should be smaller than the length of the code";
    fl:=exists(para){<l,const>:a in units|IsQuasiTwistedCyclic(C,const) where const:=[a:i in [1..l]]};
  else  
    fl:=exists(para){<m,const>:m in Divisors(n),a in units|m ne n and IsQuasiTwistedCyclic(C,const) where const:=[a:i in [1..m]]};
  end if;
  if fl then
    return true,para[2];
  else
    return false,_;
  end if;
end intrinsic;

intrinsic GeneratorPolynomialMatrix(C::CodeLinFld,l::RngIntElt:check:=false)->ModMatRngElt,[]
{Returns the generator polynomials of a quasi-cyclic or quasi-twisted cyclic code of index l arranged as a matrix.
 Additionally, the sequence of shift constants for all blocks is returned.
 When check is set to true, first check whether C is a quasi-cyclic or quasi-twisted cyclic code of index l.						 
}

  requirerange l,1,Length(C);
  require Length(C) mod l eq 0: "The index l must divide the length of the code C";
  if check then
    if not IsQuasiCyclic(C,l) then
      units:={x:x in Alphabet(C)|x ne 0};
      fl:=exists{a:a in units|IsQuasiTwistedCyclic(C,[a:i in [1..l]])};
      if not fl then
        error "The code is not known to be quasi-cyclic or quasi-twisted cyclic code of index l";
      end if;
    end if;
  end if;
  return GeneratorPolynomialMatrix(C:l:=l);
end intrinsic;



intrinsic GeneratorPolynomialMatrix(C::CodeLinFld:l:=0)->ModMatRngElt,[]
{Check whether C is a quasi-cyclic or quasi-twisted cyclic code and returns its generator polynomials arranged as a matrix.
 Additionally, the sequence of shift constants for all blocks is returned.
 The optional parameter l can be used to specify the index l of the code.
}
  if l ne 0 then
    requirerange l,1,Length(C);
    require Length(C) mod l eq 0: "The index l must divide the length of the code C";
  end if;
  F:=Alphabet(C);
  if l eq 0 then
    qc,m:=myIsQuasiCyclic(C);
    if qc then
      qt:=false;
      L:=[F!1:i in [1..m]];
    else
      qt,L:=myIsQuasiTwistedCyclic(C);
      m:=#L;
    end if;
  else
      
  end if;
  if l eq 0 and not (qc or qt) then
    error "The code is neither known to be quasi-cyclic nor quasi-twisted cyclic";
  end if;

  P:=PolynomialRing(F);
  G:=GeneratorMatrix(C);
  n:=Length(C);
  n1:=n div m;

  // convert the vectors of each quasi-cyclic block into polynomials
  M_poly:=Matrix([[P![G[i,j]:j in [a..a+n1-1]]:a in [1..n by n1]]:i in [1..Nrows(G)]]);
  // add the polynomials x^m-alpha_j for each block; do we need them?
  if l eq 0 and qc then
    M_poly:=VerticalJoin(M_poly,(P.1^n1-1)*One(MatrixRing(P,m)));
  elif l eq 0 then
    M_poly:=VerticalJoin(M_poly,DiagonalMatrix([P.1^n1-a:a in L]));
  end if;
  M_poly:=EchelonForm(M_poly);
  rk:=Maximum([0] cat [i:i in [1..Nrows(M_poly)]|M_poly[i] ne 0 and not exists{f:f in Eltseq(M_poly[i])|Degree(f) eq n1}]);
  M_poly:=RowSubmatrix(M_poly,1,rk);
  if l eq 0 then
    return M_poly,L;
  else
    return M_poly,_;
  end if;
end intrinsic;

intrinsic MinimalSuperCodes(C::CodeLinFld:l:=0,max:=0) -> {}
{Given a quasi-cyclic or quasi-twisted cyclic code C, find all minimal quasi-cyclic/quasi-twisted cyclic supercodes C1, i.e., there is no quasi-cyclic code C2 with C < C2 < C1}

  if l eq 0 then
    fl,L:=myIsQuasiTwistedCyclic(C);
  else
    fl,L:=myIsQuasiTwistedCyclic(C:l:=l);
  end if;
  if not fl then
    error "only implemented for quasi-cyclic and quasi-twisted cyclic codes";
  end if;

  l:=#L;
  n:=Length(C);
  k:=Dimension(C);
  m:=n div l;
  F:=CoefficientRing(C);
  E:=Parent(RootOfUnity(Order(L[1])*m,F));
  P:=PolynomialRing(F);
  factors:=[f[1]:f in Factorisation(P.1^m-L[1])];
  L_alpha:=[Roots(f,E)[1,1]:f in factors];
  L_ext:=[GF(#F^Degree(f)):f in factors];
  G_poly:=Matrix(P,[[P![v[i]:i in [j..j+m-1]]:j in [1..n by m]]:v in Generators(C)]);
  G_poly2:=GeneratorPolynomialMatrix(C);
  L_E:=[LinearCode(Matrix(L_ext[i],l,[Evaluate(f,L_alpha[i]):f in Eltseq(G_poly)])):i in [1..#factors]];
  L_E2:=[LinearCode(Matrix(L_ext[i],l,[Evaluate(f,L_alpha[i]):f in Eltseq(G_poly2)])):i in [1..#factors]];
  assert L_E eq L_E2;
  L_sup:={};
  anz:=&+[(q^(Length(x)-Dimension(x))-1) div (q-1) where q:=#Alphabet(x):x in L_E];
  vprintf Code,1: "%o constituents, %o supercodes\n",#L_E,anz;
  for i:=1 to #L_E do
    anz1:=(q^(n-k)-1) div (q-1) where n:=Length(L_E[i]) where k:=Dimension(L_E[i]) where q:=#Alphabet(L_E[i]);
    vprintf Code,1:"constituent %o: [%o,%o]_%o, %o supercodes\n",i,n,k,q,(q^(n-k)-1) div (q-1) where n:=Length(L_E[i]) where k:=Dimension(L_E[i]) where q:=#Alphabet(L_E[i]);
    c0:=Generic(L_E[i]);
    qc1:=&+[TraceExpansionCode(L_E[j],F,m,L_alpha[j]):j in [1..#L_E]|j ne i];
    if Dimension(L_E[i]) eq Length(L_E[i]) then
      L_v:={};
    elif Dimension(L_E[i]) eq Length(L_E[i])-1 then
      L_v:={rep{v:v in CodeComplement(c0,L_E[i])|v ne 0}};
    elif max eq 0 or anz1 le max then
      L_v:={Normalize(v):v in CodeComplement(c0,L_E[i])|v ne 0};
    else
      cc:=CodeComplement(c0,L_E[i]);
      L_v:={random{Normalize(v):v in cc|v ne 0}:j in [1..max]};
    end if;
    for v in L_v do
      c1:=sub<c0|L_E[i],v>;
      Include(~L_sup,qc1+TraceExpansionCode(c1,F,m,L_alpha[i]));
    end for;
  end for;
  assert not C in L_sup;
  return L_sup;
end intrinsic;


intrinsic MaximalSubCodes(C::CodeLinFld:l:=0,max:=0) -> {}
{Given a quasi-cyclic code C, find all maximal quasi-cyclic subcodes C1, i.e., there is no quasi-cyclic code C2 with C1 < C2 < C}
  if Dimension(C) eq 0 then
    return {Parent(C)|};
  end if;
  if l eq 0 then
    fl,L:=myIsQuasiTwistedCyclic(C);
  else
    fl,L:=myIsQuasiTwistedCyclic(C:l:=l);
  end if;
  if not fl then
    error "only implemented for quasi-cyclic and quasi-twisted cyclic codes";
  end if;
  l:=#L;
  n:=Length(C);
  k:=Dimension(C);
  m:=n div l;
  F:=CoefficientRing(C);
  E:=Parent(RootOfUnity(Order(L[1])*m,F));
  P:=PolynomialRing(F);
  factors:=[f[1]:f in Factorisation(P.1^m-L[1])];
  L_alpha:=[Roots(f,E)[1,1]:f in factors];
  L_ext:=[GF(#F^Degree(f)):f in factors];
  G_poly:=Matrix([[P![v[i]:i in [j..j+m-1]]:j in [1..n by m]]:v in Generators(C)]);
  L_E:=[LinearCode(Matrix(L_ext[i],l,[Evaluate(f,L_alpha[i]):f in Eltseq(G_poly)])):i in [1..#factors]];
  L_sub:={};
  anz:=&+[(q^Dimension(x)-1) div (q-1) where q:=#Alphabet(x):x in L_E];
  vprintf Code,1: "%o constituents, %o subcodes\n",#L_E,anz;
  for i:=1 to #L_E do
    vprintf Code,1:"constituent %o: [%o,%o]_%o, %o subcodes\n",i,n,k,q,(q^k-1) div (q-1) where n:=Length(L_E[i]) where k:=Dimension(L_E[i]) where q:=#Alphabet(L_E[i]);
    c0:=Generic(L_E[i]);
    c1_dual:=Dual(L_E[i]);
    cc:=CodeComplement(c0,c1_dual);
    qc1:=&+[TraceExpansionCode(L_E[j],F,m,L_alpha[j]):j in [1..#L_E]|j ne i];
    if Dimension(L_E[i]) eq 0 then
      L_v:={};
    elif Dimension(L_E[i]) eq 1 then
      L_v:={rep{v:v in cc|v ne 0}};
    elif max eq 0 or (#cc-1) div (#F-1) le max then
      L_v:={Normalize(v):v in cc|v ne 0};
    else
      L_v:={random{Normalize(v):v in cc|v ne 0}:j in [1..max]};
    end if;
    for v in L_v do
      c1:=Dual(sub<c0|c1_dual,v>);
      Include(~L_sub,sub<C|qc1+TraceExpansionCode(c1,F,m,L_alpha[i])>);
    end for;
  end for;
  assert not C in L_sub;
  return L_sub;
end intrinsic;
